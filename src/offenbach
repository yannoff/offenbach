#!/bin/bash
#
# This file is part of the Offenbach Project
#
# (c) 2019-2021 Yannoff (https://github.com/yannoff)
#
# @project  Offenbach
# @author   Yannoff (https://github.com/yannoff)
# @link     https://github.com/yannoff/offenbach
# @license  http://opensource.org/licenses/MIT
#
# For the full copyright and license information,
# please view the LICENSE file bundled with this
# software sources.
#

offenbach_name=Offenbach
offenbach_url=https://github.com/yannoff/offenbach
offenbach_build_version=@@version@@
offenbach_build_date=@@date@@

yamltools=yamltools
composer=composer

#
# If verbosity is set, print formatted message preprended with app name
# @param $message  The formatted debug message to print
# @param $v1...$vn The formatting values
#
_debug(){
    [ -n "${verbosity}" ] || return 0
    local msg=$1
    [ -n "${msg}" ] || return 0
    shift 1
    set -- "[offenbach] ${msg}\n" "$@"
    printf "$@" >&2
}

#
# Execute given command with debbugging and return command status
# @param $command The command to execute
#
_exec(){
    local cmd=$1 output status o
    [ "${verbosity}" = "-vv" -o "${verbosity}" = "-vvv" ] && _debug "${cmd}"
    output="$(${cmd} 2>&1)"
    status=$?
    _debug "${output}"
    return ${status}
}

#
# Copy source file to destination file
# @param $source The source file
# @param $target The destination file
#
_copy(){
    local src=$1 dest=$2
    [ -f ${src} ] && _exec "cp -v ${src} ${dest}"
    return $?
}

#
# Move source file to destination file
# @param $source The source file
# @param $target The destination file
#
# @todo Return error code and display error message if $source does not exist
#
_move(){
    local src=$1 dest=$2
    [ -f ${src} ] && _exec "mv -v ${src} ${dest}"
    return $?
}

#
# Convert YAML source file to JSON target file
# @param $source The YAML source file
# @param $target The JSON destination file
#
_yaml2json(){
    local yamlfile=$1 jsonfile=$2
    [ -f ${yamlfile} ] && _exec "${yamltools} convert:yaml:json ${yamlfile} ${jsonfile}"
    return $?
}

#
# Convert JSON source file to YAML target file
# @param $source The JSON source file
# @param $target The YAML destination file
#
_json2yaml(){
    local jsonfile=$1 yamlfile=$2
    [ -f ${jsonfile} ] && _exec "${yamltools} convert:json:yaml ${jsonfile} ${yamlfile}"
    return $?
}

#
# Restore comments from the original YAML to the new generated one
# @param $source The original YAML file with comments
# @param $target The fresh YAML file without comments
#
_restore(){
    local original=$1 newfile=$2
    [ -f ${original} ] && _exec "${yamltools} yaml:comments:merge -w ${original} ${newfile}"
    return $?
}

#
# Remove the given file, if it exists
# @param $file Path to the file to be removed
#
_remove(){
    local file=$1
    [ -f ${file} ] && _exec "rm -fv ${file}"
    return $?
}

#
# Prepend offenbach header note to the given file
# (if the file does not exist, exit nicely)
# @param $file Path to the target file
#
_add_header(){
    local yaml file=$1
    [ -f ${file} ] || return 0
    yaml=$(cat ${file})
    cat > ${file} <<-EOS
#
# This file was generated automatically by ${offenbach_name}
# @see ${offenbach_url} for details
#
${yaml}
EOS
}

#
# Print the list of available offenbach specific commands
#
_list_commands(){
    cat <<EOH

[01;34mOffenbach commands:[00m
  [01mmigrate[00m              Migrate an existing Composer project to the offenbach structure.
EOH
}

#
# Migrate initial JSON files to their YAML counterparts
#
_migrate(){
    printf "Converting: \033[01m%s\033[00m => \033[01m%s\033[00m \n" ${def_composer} ${yaml_file}
    _json2yaml ${def_composer} ${yaml_file} && _remove ${def_composer}
    printf "Converting: \033[01m%s\033[00m => \033[01m%s\033[00m \n" ${def_lockfile} ${lock_file}
    _json2yaml ${def_lockfile} ${lock_file} && _remove ${def_lockfile}
    # Since this is a migration, this is de-facto a first-run
    _add_header ${yaml_file}
    _add_header ${lock_file}
}

#
# Find the first argument to be a valid dir in the given list
# Fallback to package name if no dir found in the arguments
# @param $...args The arguments list
# @return The deduced directory
#
_get_cwd(){

    # First argument is the command name
    shift 1

    # Eliminate options from command line arguments
    for arg
    do
        _debug "Processing arg: \033[01m%s\033[00m" "${arg}"
        case ${arg} in
            -*)
            shift 1
            continue
            ;;
        esac
    done

    # If the project directory argument was supplied, use it
    if [ -d "${2}" ]
    then
        _debug "Use project directory: \033[01m%s\033[00m" "${2}"
        echo "${2}"
        return 0
    fi

    # Fallback to the package name (without vendor) as default dir otherwise
    _debug "No user-defined directory, using package name: \033[01m%s\033[00m" "${1}"
    echo "${1##*/}"
    return 0
}

#
# Change directory with a debug message
# @param $dir The directory
#
_chdir(){
    _debug "Changing working directory to: \033[01m%s\033[00m" "$1"
    cd "$1"
    _debug "CWD: %s" $PWD
}

# Parse command line arguments.
# Certain options need to be processed specifically
args=()

while [ $# -gt 0 ]
do
    arg=$1
    case "${arg}" in
        -v|-vv|-vvv)
            verbosity=${arg};
            ;;
        # Add support for dir changing via the --working-dir or -d switch
        # @see https://github.com/yannoff/offenbach/issues/18
        -d)
            cwd=$2
            shift 1
            ;;
        --working-dir=*)
            cwd=${arg##*=}
            ;;
        *)
            args+=(${arg})
            ;;
    esac
    shift 1
done

set -- "${args[@]}"

# If a working dir was supplied, change dir for it
[ -n "${cwd}" ] && _chdir ${cwd}


# Define filenames depending on the COMPOSER env var contents
# If a COMPOSER env var is set, use it to deduce the basename
# Otherwise, fallback to "composer" as default basename
base=composer

# Fetch alternative composer.json name set from environment, if any
env_composer=`printenv COMPOSER`

# If the COMPOSER env var is set, build filenames upon it
if [ -n "${env_composer}" ]
then

    _debug "Found a \033[01m%s\033[00m env variable set (value: \033[01m%s\033[00m)" COMPOSER "${env_composer}"

    # If the extension is .yaml it refers to an offenbach file
    # => Use the environment COMPOSER name for yaml_file, and use the extension for all offenbach files
    ext=${env_composer##*.}
    base=$(basename ${env_composer} .${ext})

    # Restrict allowed extensions to *.json and *.yaml
    if [ "${ext}" != "yaml" ] && [ "${ext}" != "json" ]
    then
        printf "Error: Only \033[01m*.json\033[00m or \033[01m*.yaml\033[00m are allowed for \033[01mCOMPOSER\033[00m.\n"
        printf "Exiting.\n"
        exit 2
    fi
else
    _debug "No \033[01mCOMPOSER\033[00m env variable set, falling back to default names"
fi

# Build all filenames from what was deduced in the upper block
yaml_file=${base}.yaml
yaml_orig=${base}.orig.yaml
lock_file=${base}-lock.yaml

def_composer=${base}.json
def_lockfile=${base}.lock

_debug "Using \033[01m%s\033[00m for the dependency file name" ${yaml_file}

# Process special commands
# Some commands don't need to load composer.json & composer.lock files
case $1 in
        about)
            printf "\033[01m%s\033[00m - \033[01m%s\033[00m\n" ${offenbach_name} "Overlay script providing support for composer.yaml files"
            ${composer} "$@"
            exit $?
            ;;
        create-project)
            _debug "Executing command: \033[01m%s\033[00m" "${composer} $*"
            ${composer} "$@" && \
            _chdir $(_get_cwd "$@") && \
            _migrate
            exit $?
            ;;
        --version|list)
            printf "\033[01m%s\033[00m build: \033[01m%s\033[00m %s\n" ${offenbach_name} ${offenbach_build_version} "${offenbach_build_date/T/ }"
            ${composer} "$@"
            [ "$1" == "list" ] && _list_commands
            exit 0
            ;;
        --help|help|search|selfupdate|self-update)
            ${composer} "$@"
            exit $?
            ;;
        # Offenbach specific commands (no composer call)
        migrate)
            printf "Migrating composer files to their offenbach counterparts...\n"
            _migrate
            exit $?
            ;;
esac

# Assess the situation and decide what to do:
# - if the YAML file is found, offenbach has been run at least once on the project
# => convert dependency and lock (if exists) files to their temporary JSON counterparts
# - otherwise, assume this is the first time offenbach is run
if [ -f "${yaml_file}" ]
then
    _debug "Found a \033[01m%s\033[00m file. Converting to JSON..." "${yaml_file}"
    # Keep a copy of the original composer.yaml, for later comments restore process
    _copy ${yaml_file} ${yaml_orig}
    # Create JSON temporary files from YAML original ones
    _yaml2json ${yaml_file} ${def_composer}
    _yaml2json ${lock_file} ${def_lockfile}
else
    first_run=yes

    if [ ! -f "${def_composer}" ]
    then
        _debug "No \033[01m%s\033[00m nor \033[01m%s\033[00m file found here." "${def_composer}" "${yaml_file}"
    fi
fi

# Execute composer in a secluded env, setting COMPOSER env variable to the default filename
env COMPOSER=${def_composer} ${composer} "$@"

# Convert updated JSON content back to YAML and remove the default files
_json2yaml ${def_composer} ${yaml_file} && _remove ${def_composer}
_json2yaml ${def_lockfile} ${lock_file} && _remove ${def_lockfile}

# Add offenbach header note, if appropriate
if [ -n "${first_run}" ]
then
    _add_header ${yaml_file}
fi
_add_header ${lock_file}

# Restore comments into the fresh generated composer.yaml then remove the original file
_restore ${yaml_orig} ${yaml_file} && _remove ${yaml_orig}
